<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>Java多线程 | realheisenberg</title><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java多线程</h1><a id="logo" href="/.">realheisenberg</a><p class="description">liusai201@mails.ucas.ac.cn</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java多线程</h1><div class="post-meta"><a href="/2021/02/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/#comments" class="comment-count"></a><p><span class="date">Feb 14, 2021</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="九-多线程"><a href="#九-多线程" class="headerlink" title="九. 多线程"></a>九. 多线程</h2><ul>
<li><p>进程和线程</p>
<p>进程是一个应用程序（一个进程是一个软件）</p>
<p>线程是一个进程中的执行场景/执行单元（一个进程可以启动多个线程）</p>
<p>例如：在命令行输入java HelloWorld后，会启动JVM（进程），JVM启动一个主线程调用main方法，同时再启动一个垃圾回收线程负责看护、回收垃圾。此时java程序中至少有两个线程并发</p>
</li>
<li><p>两个进程的内存相互独立，不共享</p>
<p>两个线程堆内存和方法区内存共享，栈内存独立（一个线程一个栈）</p>
</li>
<li><p>多线程并发：n个线程有n个栈空间，栈之间相互独立</p>
<p>java中的多线程机制可以提高程序的处理效率</p>
</li>
<li><p>使用多线程机制后，main方法结束程序不一定结束（main方法结束只是主线程结束、主栈空了，其他栈/线程可能还在压栈/弹栈）</p>
</li>
<li><p>对于多核CPU，可以实现真正的多线程并发（n个核可以有n个线程同时并发执行）</p>
<p>对于单核CPU，不能做到真正的多线程并发，但可以在多个线程间频繁切换执行</p>
</li>
<li><p>以下程序除垃圾回收线程外只有一个线程（程序只有一个栈）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void m1() &#123;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void m2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>java中实现线程：编写一个类，继承java.lang.Thread类，重写run方法</p>
<p>start()方法：启动分支线程，在JVM中开辟新的栈空间（一旦开辟成功，start()方法结束，线程启动成功）</p>
<p>启动成功的线程会自动调用run方法，且run方法在分支栈的栈底（main方法在主栈的栈底，run和main是平级的）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread mt &#x3D; new MyThread();</span><br><span class="line">        mt.start();		&#x2F;&#x2F;启动线程，结果是主线程和分支线程交替输出</span><br><span class="line">        &#x2F;&#x2F;mt.run();		不启动线程，按自上而下的顺序运行，先输出分支线程，再输出主线程</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(&quot;主线程:&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread extends Thread &#123;		&#x2F;&#x2F;定义线程类</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(&quot;分支线程:&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二种方法：实现java.lang.Runnable接口，重写run方法</p>
<p>这种方式更常用，可以继承其他的类</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(new MyRunnable());		&#x2F;&#x2F;Thread构造方法</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyRunnable implements Runnable &#123;		&#x2F;&#x2F;定义一个可运行的类</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;采用匿名内部类方式：</span><br><span class="line">Thread t &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">	public void run() &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>



<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><ol>
<li>新建状态：刚new出来的线程对象</li>
<li>就绪状态：新建状态调用start方法进入就绪状态。就绪状态又叫做可运行状态，表示当前线程具有抢夺CPU时间片的权利（CPU时间片就是执行权）</li>
<li>运行状态：抢夺到CPU时间片的线程执行run方法，run方法的开始执行标志着线程进入运行状态。当CPU时间片用完之后会重新回到就绪状态继续抢夺CPU时间片，再次抢到CPU时间片后会重新进入run方法继续执行</li>
<li>阻塞状态：处于运行状态的线程遇到阻塞事件（例如接收用户键盘输入、sleep方法等），进入阻塞状态，阻塞状态的线程会放弃之前占有的CPU时间片，需要回到就绪状态抢夺CPU时间片</li>
<li>死亡状态：run方法执行结束</li>
</ol>
<img src="/2021/02/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" class title="线程生命周期">

<ul>
<li><p>关于线程名（默认线程名为Thread-0、Thread-1……）</p>
<p>static Thread currentThread()方法：获取当前线程对象</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread2 t &#x3D; new MyThread2();</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(t.getName());		&#x2F;&#x2F;获取线程名字，输出Thread-0</span><br><span class="line">        t.setName(&quot;heisenberg&quot;);		&#x2F;&#x2F;设置线程名字</span><br><span class="line">        System.out.println(t.getName());		&#x2F;&#x2F;输出heisenberg</span><br><span class="line">        Thread currentThread &#x3D; Thread.currentThread();</span><br><span class="line">        &#x2F;&#x2F;main方法中当前线程就是主线程</span><br><span class="line">        System.out.println(currentThread.getName());		&#x2F;&#x2F;输出main</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread2 extends Thread&#123;</span><br><span class="line">	Thread currentThread &#x3D; Thread.currentThread();</span><br><span class="line">	&#x2F;&#x2F;t执行run方法，当前线程就是t</span><br><span class="line">	System.out.println(currentThread.getName());		&#x2F;&#x2F;输出heisenberg</span><br><span class="line">	public void run() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>static void sleep(long millis)方法：让当前线程进入休眠（进入“阻塞状态”），放弃占有CPU时间片，给其他线程使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">	System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">	try &#123;</span><br><span class="line">		Thread.sleep(1000);		&#x2F;&#x2F;睡眠1000毫秒（1秒）</span><br><span class="line">	&#125; catch (InterruptedException e) &#123;		&#x2F;&#x2F;处理异常</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关于Thread.sleep()方法的一个面试题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread t &#x3D; new MyThread();</span><br><span class="line">t.start();</span><br><span class="line">try &#123;</span><br><span class="line">	t.sleep(5000);		&#x2F;&#x2F;这行代码不会使线程t进入休眠</span><br><span class="line">	&#x2F;&#x2F;在执行时会转换成Thread.sleep();其作用是让main线程进入休眠</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Hello World&quot;);		&#x2F;&#x2F;5秒后输出</span><br></pre></td></tr></table></figure>

<ul>
<li>中断线程睡眠：interrupt()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest07 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(new MyRunnable2());</span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5000);		&#x2F;&#x2F;计时5秒</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt();		&#x2F;&#x2F;中断睡眠，这种方式依靠java异常处理机制</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyRunnable2 implements Runnable&#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;begin&quot;);</span><br><span class="line">        try &#123;		&#x2F;&#x2F;run()中的异常不能throws，只能try&#x2F;catch，子类不能比父类抛出更多异常</span><br><span class="line">            Thread.sleep(1000*60*60);		&#x2F;&#x2F;睡眠1小时</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();		&#x2F;&#x2F;输出begin后过5秒打印异常信息</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>stop()方法：强行终止线程（已过时，不建议使用）</p>
<p>缺点：线程中没有保存的数据会丢失</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.stop();</span><br></pre></td></tr></table></figure>

<ul>
<li>合理终止线程的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyRunnable3 r &#x3D; new MyRunnable3();</span><br><span class="line">        Thread t &#x3D; new Thread(r);</span><br><span class="line">        t.setName(&quot;t&quot;);</span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        r.run &#x3D; false;		&#x2F;&#x2F;把标记修改为false就结束了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyRunnable3 implements Runnable&#123;</span><br><span class="line">    boolean run &#x3D; true;		&#x2F;&#x2F;使用布尔标记</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            if (run) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                return;		&#x2F;&#x2F;return前可以进行保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程调度（了解）"><a href="#线程调度（了解）" class="headerlink" title="线程调度（了解）"></a>线程调度（了解）</h3><ul>
<li><p>常见线程调度：</p>
<ol>
<li>抢占式调度模型：哪个线程优先级高，抢到CPU时间片的概率就大。java采用的就是抢占式调度模型</li>
<li>均分式调度模型：平均分配CPU时间片，每个线程占有的CPU时间片时间长度相同</li>
</ol>
</li>
<li><p>与线程调度有关方法：</p>
<p>void setPriority(int newPriority)方法：设置线程优先级</p>
<p>int getPriority()方法：获取线程优先级</p>
<p>最低优先级1    默认优先级5    最高优先级10</p>
<p>优先级高的线程获取CPU时间片可能会多一些（大概率会多）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.MAX_PRIORITY);		&#x2F;&#x2F;常量10</span><br><span class="line">System.out.println(Thread.MIN_PRIORITY);		&#x2F;&#x2F;1</span><br><span class="line">System.out.println(Thread.NORM_PRIORITY);		&#x2F;&#x2F;5</span><br><span class="line">System.out.println(Thread.currentThread().getPriority());		&#x2F;&#x2F;默认优先级5</span><br><span class="line">Thread.currentThread().setPriority(10);</span><br><span class="line">System.out.println(Thread.currentThread().getPriority());		&#x2F;&#x2F;优先级10</span><br></pre></td></tr></table></figure>

<p>  static void yield()方法：让位，暂停当前正在执行的线程对象（不是阻塞），使线程从“运行状态”回到“就绪状态”（回到就绪状态后有可能会再次抢到时间片）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(new MyRunnable4());</span><br><span class="line">        t.setName(&quot;t&quot;);</span><br><span class="line">        t.start();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyRunnable4 implements Runnable&#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">            if (i % 10 &#x3D;&#x3D; 0) Thread.yield();		&#x2F;&#x2F;能被10整除时让位</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  void join()方法：合并线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyThread1 extends Thread&#123;</span><br><span class="line">	public void doSome()&#123;</span><br><span class="line">		MyThread2 t &#x3D; new MyThread2();</span><br><span class="line">		t.join();		&#x2F;&#x2F;当前线程进入阻塞，t线程执行，t线程执行结束后当前线程继续执行</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread2 extends Thread&#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程安全（重点）"><a href="#线程安全（重点）" class="headerlink" title="线程安全（重点）"></a>线程安全（重点）</h3><ul>
<li><p>数据存在安全问题的三个条件：</p>
<p>多线程并发、共享数据、共享数据有修改的行为</p>
</li>
<li><p>解决线程安全问题：采用线程同步机制（线程排队执行，不能并发）</p>
</li>
<li><p>异步编程模型：</p>
<p>t1线程与t2线程各自执行各自的，没有等待关系。异步就是并发</p>
</li>
<li><p>同步编程模型：</p>
<p>t1线程与t2线程在执行时其中一个必须等待另一个执行结束，存在等待关系。同步就是排队</p>
</li>
<li><p>模拟两个线程对账户取款</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AccountSafe &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Account act &#x3D; new Account();</span><br><span class="line">        Thread t1 &#x3D; new Thread(new AccountThread(act));</span><br><span class="line">        Thread t2 &#x3D; new Thread(new AccountThread(act));</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Account&#123;</span><br><span class="line">    double money &#x3D; 1000;</span><br><span class="line">    public Account() &#123;&#125;</span><br><span class="line">    public void take()&#123;</span><br><span class="line">        double lastMoney &#x3D; money - 500;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);		&#x2F;&#x2F;模拟网络延迟，最终输出两个余额都是500</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        money &#x3D; lastMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AccountThread implements Runnable&#123;</span><br><span class="line">    Account act;</span><br><span class="line">    public AccountThread(Account act) &#123;		&#x2F;&#x2F;两个线程共享一个账户对象，通过构造方法传递</span><br><span class="line">        this.act &#x3D; act;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        act.take();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;取款成功，余额：&quot; + act.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="线程同步机制synchronized"><a href="#线程同步机制synchronized" class="headerlink" title="线程同步机制synchronized(){}"></a>线程同步机制synchronized(){}</h4><p>小括号中的内容是多线程共享的数据/对象</p>
<p>在java语言中，1个对象有1把“锁”（标记），n个对象有n把锁</p>
<p>执行原理：假设有t1、t2线程，t1先执行遇到synchronized，自动占有括号中的共享对象锁，然后执行同步代码块的程序。在执行过程中如果t2也遇到synchronized，但共享对象的锁被占用，t2只能在同步代码块外等待t1执行结束。t1执行结束后释放锁，t2占有锁并开始执行。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void take()&#123;		&#x2F;&#x2F;修改取款方法</span><br><span class="line">	synchronized (this) &#123;&#125;		&#x2F;&#x2F;这里共享对象是账户对象</span><br><span class="line">	&#x2F;*</span><br><span class="line">	括号中也可以写Account类的实例变量，但不能写take方法的局部变量（不是共享对象）</span><br><span class="line">	可以写字符串&quot;abc&quot;，这样表示所有线程都要排队</span><br><span class="line">	不能写null，空指针异常</span><br><span class="line">	*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;也可以在实例方法上使用synchronized：这种方法锁的是this</span><br><span class="line">&#x2F;&#x2F;synchronized出现在实例方法上表示整个方法体都需要同步，可能扩大同步范围，降低执行效率。不常用</span><br><span class="line">&#x2F;&#x2F;如果共享对象是this，且需要同步的代码块是整个方法体，建议使用这种方式。</span><br><span class="line">public synchronized void take()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三种方法：在静态方法上使用synchronized，表示找类锁。类锁只有一把，与对象数量无关</span><br></pre></td></tr></table></figure>

<ul>
<li><p>处于运行状态的线程遇到synchronized关键字就会在锁池（lockpool）中寻找共享对象的对象锁，释放之前占有的CPU时间片。如果没有找到就在锁池中等待，找到后进入就绪状态继续抢夺CPU时间片</p>
</li>
<li><p>java中三大变量：</p>
<p>实例变量：堆    静态变量：方法区    局部变量：栈</p>
<p>其中局部变量不共享，不存在线程安全问题（堆和方法区只有1个，而1个线程1个栈）</p>
</li>
<li><p>在开发中如何解决线程安全问题？</p>
<ol>
<li>尽量使用局部变量代替实例变量和静态变量</li>
<li>如果必须使用实例变量，可以创建多个对象，内存不共享</li>
<li>如果都不行，用synchronized，线程同步机制</li>
</ol>
</li>
<li><p>面试题1：doOther方法执行时需要等待doSome方法的结束吗？不需要</p>
<p>doOther方法没有synchronized关键字</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Exam01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyClass mc &#x3D; new MyClass();</span><br><span class="line">        MyThread4 t1 &#x3D; new MyThread4(mc);</span><br><span class="line">        MyThread4 t2 &#x3D; new MyThread4(mc);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);		&#x2F;&#x2F;保证t1方法先执行</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread4 extends Thread&#123;</span><br><span class="line">    MyClass mc;</span><br><span class="line">    public MyThread4(MyClass mc)&#123;</span><br><span class="line">        this.mc &#x3D; mc;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        if (Thread.currentThread().getName().equals(&quot;t1&quot;))&#123;</span><br><span class="line">            mc.doSome();</span><br><span class="line">        &#125;</span><br><span class="line">        if (Thread.currentThread().getName().equals(&quot;t2&quot;))&#123;</span><br><span class="line">            mc.doOther();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyClass&#123;</span><br><span class="line">    public synchronized void doSome()&#123;</span><br><span class="line">        System.out.println(&quot;dosome begin&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000 * 10);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;dosome over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void doOther()&#123;		&#x2F;&#x2F;加上synchronized就需要排队了</span><br><span class="line">        System.out.println(&quot;doother begin&quot;);</span><br><span class="line">        System.out.println(&quot;doother over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">如果doSome方法和doOther方法写成：</span><br><span class="line">public synchronized static void doSome()&#123;&#125;</span><br><span class="line">public synchronized static void doOther()&#123;&#125;</span><br><span class="line">synchronized出现在静态方法上表示找类锁，此时需要排队执行</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>synchronized最好不要嵌套使用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;死锁举例：</span><br><span class="line">public class DeadLock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o1 &#x3D; new Object();</span><br><span class="line">        Object o2 &#x3D; new Object();</span><br><span class="line">        Thread t1 &#x3D; new MyThread1(o1, o2);</span><br><span class="line">        Thread t2 &#x3D; new MyThread2(o1, o2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread1 extends Thread&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">    public MyThread1(Object o1, Object o2)&#123;</span><br><span class="line">        this.o1 &#x3D; o1;</span><br><span class="line">        this.o2 &#x3D; o2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        synchronized (o1)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (o2)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread2 extends Thread&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">    public MyThread2(Object o1, Object o2)&#123;</span><br><span class="line">        this.o1 &#x3D; o1;</span><br><span class="line">        this.o2 &#x3D; o2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        synchronized (o2)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (o1)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4></li>
<li><p>java语言中线程分为两大类：</p>
<ol>
<li>用户线程</li>
<li>守护线程（后台线程，例如垃圾回收线程、系统每天在0:00自动备份，可以将定时器设为守护线程）</li>
</ol>
</li>
<li><p>一般守护线程是一个死循环，所有用户线程结束（主线程main方法是一个用户线程），守护线程自动结束</p>
</li>
<li><p>设置守护线程方法：setDaemon(true)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t &#x3D; new MyThread5();</span><br><span class="line">        t.setName(&quot;守护线程&quot;);</span><br><span class="line">        t.setDaemon(true);</span><br><span class="line">        t.start();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;		&#x2F;&#x2F;用户线程：主线程</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread5 extends Thread&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;当主线程输出到9时守护线程自动结束</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4></li>
<li><p>定时器的作用：间隔特定时间，执行特定操作（sleep方法是最原始的定时器）</p>
</li>
<li><p>java的类库中有定时器：java.util.Timer。实际开发中使用较少，通常使用Spring框架中的SpringTask框架</p>
<p>timer.schedule(定时任务, 第一次执行时间, 间隔时间)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TimerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Timer timer &#x3D; new Timer();		&#x2F;&#x2F;创建定时器对象</span><br><span class="line">        &#x2F;&#x2F;Timer timer &#x3D; new Timer(true);		&#x2F;&#x2F;设置为守护线程</span><br><span class="line">        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        Date firstDate &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            firstDate &#x3D; sdf.parse(&quot;2021-03-07 19:47:20&quot;);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        timer.schedule(new LogTimerTask(), firstDate, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class LogTimerTask extends TimerTask&#123;		&#x2F;&#x2F;定时任务类</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String time &#x3D; sdf.format(new Date());</span><br><span class="line">        System.out.println(time + &quot;完成一次数据备份&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="实现线程的第三种方式：实现Callable接口（JDK8新特性）"><a href="#实现线程的第三种方式：实现Callable接口（JDK8新特性）" class="headerlink" title="实现线程的第三种方式：实现Callable接口（JDK8新特性）"></a>实现线程的第三种方式：实现Callable接口（JDK8新特性）</h4><p>优点：可以获取线程执行结果</p>
<p>缺点：在获取t线程结果时，当前线程受阻塞，效率较低</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">	&#x2F;&#x2F;第一步：创建一个“未来任务类”对象，传递一个Callable接口实现对象</span><br><span class="line">	FutureTask task &#x3D; new FutureTask(new Callable() &#123;		&#x2F;&#x2F;匿名内部类</span><br><span class="line">		public Object call() throws Exception &#123;</span><br><span class="line">			System.out.println(&quot;call method begin&quot;);</span><br><span class="line">			Thread.sleep(1000 * 10);</span><br><span class="line">			System.out.println(&quot;call method end&quot;);</span><br><span class="line">			return 20;		&#x2F;&#x2F;自动装箱</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	Thread t &#x3D; new Thread(task);		&#x2F;&#x2F;创建线程对象</span><br><span class="line">	t.start();</span><br><span class="line">	System.out.println(task.get());		&#x2F;&#x2F;get方法执行时当前线程受阻塞</span><br><span class="line">	System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="Object类的wait和notify方法（生产者和消费者模式）"><a href="#Object类的wait和notify方法（生产者和消费者模式）" class="headerlink" title="Object类的wait和notify方法（生产者和消费者模式）"></a>Object类的wait和notify方法（生产者和消费者模式）</h4><ol>
<li><p>任何java对象都有wait和notify方法</p>
</li>
<li><p>wait方法让正在o对象上活动的线程进入无限期等待状态，并且释放之前占有的o对象的锁，直到被唤醒为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o &#x3D; new Object();</span><br><span class="line">o.wait();</span><br></pre></td></tr></table></figure>
</li>
<li><p>notify方法唤醒正在o对象上等待的线程；notifyAll()方法唤醒在o对象上等待的所有线程</p>
<p>o.notify()只会通知，不会释放之前占有的o对象的锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o &#x3D; new Object();</span><br><span class="line">o.wait();</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者消费者模式</p>
<p>一个线程负责生产（Producer），一个线程负责消费（Consumer），最终达到生产和消费的均衡：生产满了就不能继续生产，必须让消费者进行消费；消费完了就不能再消费，必须让生产者进行生产</p>
<p>wait方法和notify方法建立在synchronized线程同步的基础上</p>
</li>
</ol>
</li>
<li><p>模拟生产者和消费者模式</p>
<p>仓库为List集合，只能存储一个元素，生产一个消费一个</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List list &#x3D; new ArrayList();</span><br><span class="line">        Thread t1 &#x3D; new Thread(new Producer(list));</span><br><span class="line">        Thread t2 &#x3D; new Thread(new Consumer(list));</span><br><span class="line">        t1.setName(&quot;生产者线程&quot;);</span><br><span class="line">        t2.setName(&quot;消费者线程&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Producer implements Runnable &#123;</span><br><span class="line">    private List list;</span><br><span class="line">    public Producer(List list) &#123;</span><br><span class="line">        this.list &#x3D; list;		&#x2F;&#x2F;共享仓库对象</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;		&#x2F;&#x2F;死循环模拟一直生产</span><br><span class="line">            synchronized (list) &#123;</span><br><span class="line">                if (list.size() &gt; 0) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Object obj &#x3D; new Object();</span><br><span class="line">                list.add(obj);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + obj);</span><br><span class="line">                list.notify();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Consumer implements Runnable &#123;</span><br><span class="line">    private List list;</span><br><span class="line">    public Consumer(List list) &#123;</span><br><span class="line">        this.list &#x3D; list;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (list) &#123;</span><br><span class="line">                if (list.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Object obj &#x3D; list.remove(0);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + obj);</span><br><span class="line">                list.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><blockquote><p>Original author: Liu Sai</p><p>Original link: <a href="http://example.com/2021/02/14/Java多线程/">http://example.com/2021/02/14/Java多线程/</a></p><p>Copyright Notice: Please indicate the source of the reprint (must retain the author's signature and link)</p></blockquote></div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2021/03/08/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="pre">Java反射机制</a><a href="/2021/02/01/JavaIO%E6%B5%81/" class="next">JavaIO流</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">九. 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">线程调度（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">线程安全（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6synchronized"><span class="toc-text">线程同步机制synchronized(){}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%88JDK8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-text">实现线程的第三种方式：实现Callable接口（JDK8新特性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E7%B1%BB%E7%9A%84wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-text">Object类的wait和notify方法（生产者和消费者模式）</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/08/23/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8B%EF%BC%89/">社区项目（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/09/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8A%EF%BC%89/">社区项目（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/27/SpringMVC/">SpringMVC</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/20/Maven/">Maven</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/19/MyBatis/">MyBatis</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/05/Spring/">Spring</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/21/JavaWeb%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ACookie%E3%80%81Session%E3%80%81Filter%E3%80%81JSON%E3%80%81AJAX/">JavaWeb（三）：Cookie、Session、Filter、JSON、AJAX</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/08/JavaWeb%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AXML%E3%80%81Servlet%E3%80%81jsp%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/">JavaWeb（二）：XML、Servlet、jsp、EL表达式、JSTL标签库</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/08/%E5%B0%9A%E7%A1%85%E8%B0%B7%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE/">尚硅谷书城项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/13/JavaWeb%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTML%E3%80%81CSS%E3%80%81JavaScript%E3%80%81jQuery/">JavaWeb（一）：HTML、CSS、JavaScript、jQuery</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/JDBC/" style="font-size: 15px;">JDBC</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE/" style="font-size: 15px;">尚硅谷书城项目</a> <a href="/tags/%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE/" style="font-size: 15px;">社区项目</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">11</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Liu Sai.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a target="_blank" rel="noopener" href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>